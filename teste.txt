Tendo como base o código a seguir, desenvolva uma função para desenhar 
polígonos, dadas quatro ou mais coordenadas. Me dê o código apenas do que será modificado
//Enumeracao com os tipos de formas geometricas
enum tipo_forma{LIN = 0, TRI, RET, POL, CIR }; // Linha, Triangulo, Retangulo Poligono, Circulo

//Verifica se foi realizado o primeiro clique do mouse
bool click1, clickQuad, clickTri2, clickTri3 = false;

//Coordenadas da posicao atual do mouse
int m_x, m_y;

//Coordenadas do primeiro clique e do segundo clique do mouse
int x_1, y_1, x_2, y_2, x_3, y_3;

//Indica o tipo de forma geometrica ativa para desenhar
int modo = LIN;

//Largura e altura da janela
int width = 512, height = 512;

// Definicao de vertice
struct vertice{
    int x;
    int y;
};

// Definicao das formas geometricas
struct forma{
    int tipo;
    forward_list<vertice> v; //lista encadeada de vertices
};

// Lista encadeada de formas geometricas
forward_list<forma> formas;

// Funcao para armazenar uma forma geometrica na lista de formas
// Armazena sempre no inicio da lista
void pushForma(int tipo){
    forma f;
    f.tipo = tipo;
    formas.push_front(f);
}

// Funcao para armazenar um vertice na forma do inicio da lista de formas geometricas
// Armazena sempre no inicio da lista
void pushVertice(int x, int y){
    vertice v;
    v.x = x;
    v.y = y;
    formas.front().v.push_front(v);
}

//Fucao para armazenar uma Linha na lista de formas geometricas
void pushLinha(int x_1, int y1, int x_2, int y_2){
    pushForma(LIN);
    pushVertice(x_1, y1);
    pushVertice(x_2, y_2);
}

void pushQuadrilatero(int x_1, int y1, int x_2, int y_2) {
	pushForma(RET);
	pushVertice(x_1, y1);
    pushVertice(x_2, y_2);
}

void mouse(int button, int state, int x, int y){
    switch (button) {
        case GLUT_LEFT_BUTTON: {
			switch(modo){
                	case LIN: {
                        if (state == GLUT_DOWN) {
	                        if(click1){
	                            x_2 = x;
	                            y_2 = height - y - 1;
	                            printf("Clique 2(%d, %d)\n",x_2,y_2);
	                            pushLinha(x_1, y_1, x_2, y_2);
	                            click1 = false;
	                            glutPostRedisplay();
	                        }else{
	                            click1 = true;
	                            x_1 = x;
	                            y_1 = height - y - 1;
	                            printf("Clique 1(%d, %d)\n",x_1,y_1);
	                        }
	                    }
					    break;
                    }
		   case RET: {
                        if (state == GLUT_DOWN) {
	                        if(clickQuad){
	                            x_2 = x;
	                            y_2 = height - y - 1;
	                            printf("Clique 2(%d, %d)\n",x_2,y_2);
	                            pushQuadrilatero(x_1, y_1, x_2, y_2);
	                            clickQuad = false;
	                            glutPostRedisplay();
	                        }else{
	                            clickQuad = true;
	                            x_1 = x;
	                            y_1 = height - y - 1;
						   	}
	  	  	           }	
                	    break;
                    }
}


/*
 * Controle da posicao do cursor do mouse
 */
void mousePassiveMotion(int x, int y){
    m_x = x; m_y = height - y - 1;
    glutPostRedisplay();
}

/*
 * Funcao para desenhar apenas um pixel na tela
 */
void drawPixel(int x, int y){
    glBegin(GL_POINTS); // Seleciona a primitiva GL_POINTS para desenhar
	glVertex2i(x, y);
    glEnd();  // indica o fim do ponto
}

/*
 *Funcao que desenha a lista de formas geometricas
 */
void drawFormas(){
    //Apos o primeiro clique, desenha a reta com a posicao atual do mouse
    if(click1) bresenhamLine(x_1, y_1, m_x, m_y);
    else if(clickQuad) quadrilatero(x_1, y_1, m_x, m_y);
    else if(clickTri2) bresenhamLine(x_1, y_1, m_x, m_y);
    else if(clickTri3) triangulo(x_1, y_1, x_2, y_2 ,m_x, m_y);
    
    //Percorre a lista de formas geometricas para desenhar
    for(forward_list<forma>::iterator f = formas.begin(); f != formas.end(); f++){
        switch (f->tipo) {
            case LIN: 
			{
				int i = 0, x[2], y[2];
                //Percorre a lista de vertices da forma linha para desenhar
                for(forward_list<vertice>::iterator v = f->v.begin(); v != f->v.end(); v++, i++){
                    x[i] = v->x;
                    y[i] = v->y;
                }
                //Desenha o segmento de reta apos dois cliques
                bresenhamLine(x[0], y[0], x[1], y[1]);
            	break;
            }
	    case RET: 
			{
				int r = 0, x[2], y[2];
                //Percorre a lista de vertices da forma linha para desenhar
                for(forward_list<vertice>::iterator v = f->v.begin(); v != f->v.end(); v++, r++){
                    x[r] = v->x;
                    y[r] = v->y;
                }
                //Desenha o quadrilatero
                quadrilatero(x[0], y[0], x[1], y[1]);
                break;
            }	
        }
    }
}

void bresenhamLine(int x_1, int y_1, int x_2, int y_2){
    // código do algoritmo de bresenham
}

void quadrilatero(int x1, int y1, int x2, int y2){
    bresenhamLine(x1, y1, x2, y1);
    bresenhamLine(x2, y1, x2, y2);
    bresenhamLine(x2, y2, x1, y2);
    bresenhamLine(x1, y2, x1, y1);
}